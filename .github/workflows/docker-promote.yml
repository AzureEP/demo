# .github/workflows/docker-promote.yml
# Promote image from dev → prod in JFrog Artifactory (no rebuild), verify digest parity,
# and create a GitHub Release (v<version>) that maps release ↔ commit ↔ digests.

name: Docker — Promote to prod

on:
  workflow_dispatch:
    inputs:
      sourceTag:
        description: "Dev tag to promote (e.g., git-104c263)"
        required: true
      targetTag:
        description: "Prod tag (release version, e.g., 0.1.0). Leave blank to reuse sourceTag"
        required: false

permissions:
  contents: write

jobs:
  promote:
    runs-on: ubuntu-latest
    # Needed for creating the GitHub Release
    permissions:
      contents: write
    environment:
      name: prod   # Protect this env in GitHub → Settings → Environments → prod

    env:
      # Set these as Repository Variables (Settings → Variables):
      #   JF_URL=https://chirag095.jfrog.io
      #   JF_DOCKER_REGISTRY=chirag095.jfrog.io
      #   DOCKER_DEV_REPO=petclinic-demo
      #   DOCKER_PROD_REPO=petclinic-prd
      JF_URL:              ${{ vars.JF_URL }}
      JF_DOCKER_REGISTRY:  ${{ vars.JF_DOCKER_REGISTRY }}
      DOCKER_DEV_REPO:     ${{ vars.DOCKER_DEV_REPO }}
      DOCKER_PROD_REPO:    ${{ vars.DOCKER_PROD_REPO }}
      IMAGE_NAME:          spring-petclinic

    steps:
      - name: Checkout (to resolve full commit SHA)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Compute variables (source/target tags, commit)
        id: vars
        shell: bash
        run: |
          set -euo pipefail
          SRC="${{ github.event.inputs.sourceTag }}"
          TGT="${{ github.event.inputs.targetTag }}"
          if [ -z "$TGT" ]; then TGT="$SRC"; fi

          SHORT="${SRC#git-}"
          # Resolve to full commit SHA in this repo (fallback to SHORT if not found)
          if git rev-parse --verify "${SHORT}^{commit}" >/dev/null 2>&1; then
            FULL=$(git rev-parse --verify "${SHORT}^{commit}")
          else
            FULL="$SHORT"
          fi

          echo "src=$SRC"            >> "$GITHUB_OUTPUT"
          echo "tgt=$TGT"            >> "$GITHUB_OUTPUT"
          echo "short_commit=$SHORT" >> "$GITHUB_OUTPUT"
          echo "full_commit=$FULL"   >> "$GITHUB_OUTPUT"

          echo "Source tag : $SRC"
          echo "Target tag : $TGT"
          echo "Full commit: $FULL"

      - name: Promote via Artifactory Docker Promote API (copy layers; no rebuild)
        shell: bash
        run: |
          set -euo pipefail
          SRC="${{ steps.vars.outputs.src }}"
          TGT="${{ steps.vars.outputs.tgt }}"

          URL="${{ env.JF_URL }}/artifactory/api/docker/${{ env.DOCKER_DEV_REPO }}/v2/promote"
          JSON=$(printf '{"targetRepo":"%s","dockerRepository":"%s","tag":"%s","targetTag":"%s","copy":true}' \
                 "${{ env.DOCKER_PROD_REPO }}" "${{ env.IMAGE_NAME }}" "$SRC" "$TGT")
          echo "POST $URL"
          echo "$JSON"
          curl -sS -u "${{ secrets.JFROG_USER }}:${{ secrets.JFROG_TOKEN }}" \
               -H "Content-Type: application/json" \
               -d "$JSON" \
               "$URL" -o /tmp/promote.json
          echo "Response:"; cat /tmp/promote.json

      - name: Verify digest parity (robust)
        id: digests
        shell: bash
        env:
          NAME: ${{ env.IMAGE_NAME }}
        run: |
          set -euo pipefail

          SRC="${{ steps.vars.outputs.src }}"
          TGT="${{ steps.vars.outputs.tgt }}"
          DEV_REPO="${{ env.DOCKER_DEV_REPO }}"
          PRD_REPO="${{ env.DOCKER_PROD_REPO }}"
          NAME="${NAME}"

          # Registry endpoints (preferred for digest header)
          DEV_REG_URL="https://${{ env.JF_DOCKER_REGISTRY }}/v2/${DEV_REPO}/${NAME}/manifests/${SRC}"
          PRD_REG_URL="https://${{ env.JF_DOCKER_REGISTRY }}/v2/${PRD_REPO}/${NAME}/manifests/${TGT}"

          # Artifactory API endpoints (secondary)
          DEV_API_URL="${{ env.JF_URL }}/artifactory/api/docker/${DEV_REPO}/v2/${NAME}/manifests/${SRC}"
          PRD_API_URL="${{ env.JF_URL }}/artifactory/api/docker/${PRD_REPO}/v2/${NAME}/manifests/${TGT}"

          # Try to fetch Docker-Content-Digest header with correct Accept types
          get_digest() {
            local url="$1"
            local hdrs=""
            local val=""
            for accept in \
              'application/vnd.docker.distribution.manifest.v2+json' \
              'application/vnd.oci.image.manifest.v1+json' \
              'application/vnd.oci.image.index.v1+json'
            do
              hdrs=$(curl -sSI -u "${{ secrets.JFROG_USER }}:${{ secrets.JFROG_TOKEN }}" -H "Accept: ${accept}" "$url" || true)
              val=$(printf '%s' "$hdrs" | tr -d '\r' | awk -F': ' 'tolower($1)=="docker-content-digest"{print $2}' | tail -n1)
              if [ -n "$val" ]; then
                echo "$val"
                return 0
              fi
            done
            echo ""
            return 1
          }

          # Fallback: compute digest by hashing the manifest bytes we GET
          get_digest_by_hash() {
            local url="$1"
            local body="/tmp/manifest.$RANDOM.json"
            curl -sS -u "${{ secrets.JFROG_USER }}:${{ secrets.JFROG_TOKEN }}" \
                 -H "Accept: application/vnd.docker.distribution.manifest.v2+json" \
                 "$url" -o "$body" || true
            if [ -s "$body" ]; then
              local sum
              sum=$(sha256sum "$body" | cut -d' ' -f1)
              echo "sha256:${sum}"
              return 0
            fi
            echo ""
            return 1
          }

          # Dev digest: try registry → API → hash
          DEV_DIG=""
          for url in "$DEV_REG_URL" "$DEV_API_URL"; do
            DEV_DIG=$(get_digest "$url") && [ -n "$DEV_DIG" ] && break || true
          done
          if [ -z "$DEV_DIG" ]; then
            for url in "$DEV_REG_URL" "$DEV_API_URL"; do
              DEV_DIG=$(get_digest_by_hash "$url") && [ -n "$DEV_DIG" ] && break || true
            done
          fi

          # Prod digest: try registry → API → hash
          PRD_DIG=""
          for url in "$PRD_REG_URL" "$PRD_API_URL"; do
            PRD_DIG=$(get_digest "$url") && [ -n "$PRD_DIG" ] && break || true
          done
          if [ -z "$PRD_DIG" ]; then
            for url in "$PRD_REG_URL" "$PRD_API_URL"; do
              PRD_DIG=$(get_digest_by_hash "$url") && [ -n "$PRD_DIG" ] && break || true
            done
          fi

          echo "Dev  digest: $DEV_DIG"
          echo "Prod digest: $PRD_DIG"
          [ -n "$DEV_DIG" ]  || { echo "::error::Missing dev digest";  exit 1; }
          [ -n "$PRD_DIG" ]  || { echo "::error::Missing prod digest"; exit 1; }
          [ "$DEV_DIG" = "$PRD_DIG" ] || { echo "::error::Digest mismatch after promotion"; exit 1; }

          echo "dev_digest=$DEV_DIG"   >> "$GITHUB_OUTPUT"
          echo "prod_digest=$PRD_DIG"  >> "$GITHUB_OUTPUT"
          echo "Promotion OK — digests match ✅"

      - name: Create release mapping JSON
        id: mapping
        shell: bash
        run: |
          set -euo pipefail
          SRC="${{ steps.vars.outputs.src }}"
          TGT="${{ steps.vars.outputs.tgt }}"
          FULL="${{ steps.vars.outputs.full_commit }}"
          IMG="${{ env.IMAGE_NAME }}"
          DEV="${{ env.DOCKER_DEV_REPO }}"
          PRD="${{ env.DOCKER_PROD_REPO }}"
          DEV_DIG="${{ steps.digests.outputs.dev_digest }}"
          PRD_DIG="${{ steps.digests.outputs.prod_digest }}"

          printf '%s\n' "{
            \"version\": \"${TGT}\",
            \"commit\":  \"${FULL}\",
            \"image\":   \"${IMG}\",
            \"dev\":  { \"repo\": \"${DEV}\",  \"tag\": \"${SRC}\", \"digest\": \"${DEV_DIG}\" },
            \"prod\": { \"repo\": \"${PRD}\", \"tag\": \"${TGT}\", \"digest\": \"${PRD_DIG}\" },
            \"ci_run\": \"${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}\",
            \"created\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"
          }" > release-mapping.json
          echo "map_file=release-mapping.json" >> "$GITHUB_OUTPUT"

      - name: Create GitHub Release (v<version> → commit)
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ steps.vars.outputs.tgt }}
          target_commitish: ${{ steps.vars.outputs.full_commit }}
          name: Release ${{ steps.vars.outputs.tgt }}
          body: |
            Release **${{ steps.vars.outputs.tgt }}**
            - Commit: `${{ steps.vars.outputs.full_commit }}`
            - Dev tag: `${{ env.DOCKER_DEV_REPO }}:${{ steps.vars.outputs.src }}`
            - Prod tag: `${{ env.DOCKER_PROD_REPO }}:${{ steps.vars.outputs.tgt }}`
            - Digest: `${{ steps.digests.outputs.prod_digest }}`
          files: |
            ${{ steps.mapping.outputs.map_file }}

      - name: Upload mapping as workflow artifact (optional duplicate)
        uses: actions/upload-artifact@v4
        with:
          name: release-mapping-${{ steps.vars.outputs.tgt }}
          path: ${{ steps.mapping.outputs.map_file }}
