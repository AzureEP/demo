# .github/workflows/publish.yml
# SIMPLE + ROBUST (no jq, no GAVC):
# - Build & test Spring PetClinic
# - Set version to include commit id (…-g<sha>-SNAPSHOT) so Artifactory snapshot names include the commit
# - Single Maven run (clean deploy) → same bytes locally and remotely
# - Resolve the exact remote snapshot filename from maven-metadata.xml
# - Create a local copy named exactly like remote + .sha256
# - Validate checksum parity via Artifactory HEAD header (X-Checksum-Sha256)
# - Upload local copy + checksum as a GitHub artifact

name: Build and Publish to JFrog Artifactory

on:
  push:
    branches: ["main"]
  workflow_dispatch:

permissions:
  contents: read

jobs:
  build-and-publish:
    runs-on: ubuntu-latest

    env:
      # REQUIRED repo settings:
      #   Secrets:  JFROG_USER, JFROG_TOKEN
      #   Variables: JF_URL (e.g., https://yourorg.jfrog.io)
      #              JF_MVN_SNAPSHOTS_REPO (e.g., maven-snapshots-local)
      JFROG_USER:  ${{ secrets.JFROG_USER }}
      JFROG_TOKEN: ${{ secrets.JFROG_TOKEN }}
      JF_URL:      ${{ vars.JF_URL }}
      SNAP_REPO:   ${{ vars.JF_MVN_SNAPSHOTS_REPO }}

      ARTIFACT_DIR: dist
      MVN_FLAGS: "-B -ntp -C -e"   # batch, no transfer progress, strict checksums, stacktraces

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Writes ~/.m2/settings.xml with <server id="artifactory"> using ENV VAR NAMES below
      - name: Setup JDK 17 + Maven server creds
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "17"
          cache: maven
          server-id: artifactory
          server-username: JFROG_USER      # NAME of env var (not the secret value)
          server-password: JFROG_TOKEN     # NAME of env var (not the secret value)

      - name: Toolchain versions
        shell: bash
        run: |
          set -eux
          java -version
          mvn -version

      - name: Build timestamp & short commit (from last commit)
        id: ts
        shell: bash
        run: |
          set -euo pipefail
          COMMIT_TS=$(git log -1 --format=%ct)
          echo "iso=$(date -u -d @${COMMIT_TS} +%Y-%m-%dT%H:%M:%SZ)" >> "$GITHUB_OUTPUT"
          echo "compact=$(date -u -d @${COMMIT_TS} +%Y%m%dT%H%M%SZ)" >> "$GITHUB_OUTPUT"
          echo "short_sha=${GITHUB_SHA::7}" >> "$GITHUB_OUTPUT"

      - name: Set version to include commit id (…-g<sha>-SNAPSHOT)
        id: ver
        shell: bash
        run: |
          set -euo pipefail
          CURR=$(mvn -q -DforceStdout help:evaluate -Dexpression=project.version)
          BASE="${CURR%-SNAPSHOT}"                          # drop -SNAPSHOT if present
          NEW="${BASE}-g${{ steps.ts.outputs.short_sha }}-SNAPSHOT"
          echo "Setting version: ${NEW}"
          mvn -q -DgenerateBackupPoms=false versions:set -DnewVersion="${NEW}"
          echo "new_version=${NEW}" >> "$GITHUB_OUTPUT"

      - name: Build, test, and deploy (single Maven run)
        shell: bash
        run: |
          set -euo pipefail
          DEPLOY_URL="${JF_URL%/}/artifactory/${SNAP_REPO}"
          echo "Deploying to: ${DEPLOY_URL}"
          mvn $MVN_FLAGS \
            -Dproject.build.outputTimestamp="${{ steps.ts.outputs.iso }}" \
            -DaltDeploymentRepository=artifactory::default::"${DEPLOY_URL}" \
            clean deploy

      - name: Resolve remote snapshot filename from maven-metadata.xml
        id: remotename
        shell: bash
        env:
          NEW_VERSION: ${{ steps.ver.outputs.new_version }}
        run: |
          set -euo pipefail
          GID=$(mvn -q -DforceStdout help:evaluate -Dexpression=project.groupId)
          AID=$(mvn -q -DforceStdout help:evaluate -Dexpression=project.artifactId)
          GROUP_PATH=$(echo "$GID" | tr '.' '/')
          BASE="${NEW_VERSION%-SNAPSHOT}"

          META_URL="${JF_URL%/}/artifactory/${SNAP_REPO}/${GROUP_PATH}/${AID}/${NEW_VERSION}/maven-metadata.xml"
          echo "Fetching metadata: ${META_URL}"

          # small retry in case metadata isn't ready immediately
          for i in 1 2 3 4 5; do
            META_XML=$(curl -sS -u "${JFROG_USER}:${JFROG_TOKEN}" -H "Accept: application/xml" "$META_URL" || true)
            # Try modern <snapshotVersions><snapshotVersion><extension>jar</extension><value>...</value></snapshotVersion>
            ONE=$(echo "$META_XML" | tr -d '\n')
            UNIQ=$(echo "$ONE" | sed -n 's:.*<snapshotVersion><extension>jar</extension><value>\([^<]*\)</value>.*:\1:p')
            if [ -n "$UNIQ" ]; then
              REMOTE_FILE="${AID}-${UNIQ}.jar"
              break
            fi
            # Fallback to legacy <timestamp>/<buildNumber>
            TS=$(echo "$META_XML" | sed -n 's:.*<timestamp>\(.*\)</timestamp>.*:\1:p' | head -n1)
            BN=$(echo "$META_XML" | sed -n 's:.*<buildNumber>\(.*\)</buildNumber>.*:\1:p' | head -n1)
            if [ -n "$TS" ] && [ -n "$BN" ]; then
              REMOTE_FILE="${AID}-${BASE}-${TS}-${BN}.jar"
              break
            fi
            echo "Metadata not ready (attempt $i); waiting…"
            sleep 2
          done

          if [ -z "${REMOTE_FILE:-}" ]; then
            echo "::error::Unable to determine snapshot filename from metadata."; exit 1
          fi
          echo "remote_name=${REMOTE_FILE}" >> "$GITHUB_OUTPUT"
          echo "group_path=${GROUP_PATH}"   >> "$GITHUB_OUTPUT"
          echo "artifact_id=${AID}"         >> "$GITHUB_OUTPUT"

      - name: Make local copy + sha256 (named exactly like remote)
        id: stage
        shell: bash
        env:
          REMOTE_NAME: ${{ steps.remotename.outputs.remote_name }}
        run: |
          set -euo pipefail
          mkdir -p "${ARTIFACT_DIR}"
          SRC_JAR=$(ls target/*.jar | head -n1)
          cp "${SRC_JAR}" "${ARTIFACT_DIR}/${REMOTE_NAME}"
          (cd "${ARTIFACT_DIR}" && sha256sum "${REMOTE_NAME}" > "${REMOTE_NAME}.sha256")
          echo "out_name=${REMOTE_NAME}" >> "$GITHUB_OUTPUT"
          echo "local_sha256=$(cut -d' ' -f1 ${ARTIFACT_DIR}/${REMOTE_NAME}.sha256)" >> "$GITHUB_OUTPUT"

      - name: Validate checksum with Artifactory (HEAD header)
        shell: bash
        env:
          GROUP_PATH:  ${{ steps.remotename.outputs.group_path }}
          ARTIFACT_ID: ${{ steps.remotename.outputs.artifact_id }}
          VERSION:     ${{ steps.ver.outputs.new_version }}
          REMOTE_NAME: ${{ steps.remotename.outputs.remote_name }}
          LOCAL_NAME:  ${{ steps.stage.outputs.out_name }}
        run: |
          set -euo pipefail
          FILE_URL="${JF_URL%/}/artifactory/${SNAP_REPO}/${GROUP_PATH}/${ARTIFACT_ID}/${VERSION}/${REMOTE_NAME}"
          echo "HEAD ${FILE_URL}"
          # short retry in case file isn't immediately accessible via CDN/edge
          REMOTE_SHA256=""
          for i in 1 2 3 4 5; do
            HDRS=$(curl -sS -I -u "${JFROG_USER}:${JFROG_TOKEN}" "${FILE_URL}" || true)
            CODE=$(echo "$HDRS" | tr -d '\r' | awk 'NR==1{print $2}')
            echo "HTTP $CODE (attempt $i)"
            REMOTE_SHA256=$(echo "$HDRS" | tr -d '\r' | awk -F': ' 'tolower($1)=="x-checksum-sha256"{print $2}' | tail -n1)
            [ "$CODE" = "200" ] && [ -n "$REMOTE_SHA256" ] && break
            sleep 2
          done
          if [ -z "$REMOTE_SHA256" ]; then
            echo "::error::Could not obtain X-Checksum-Sha256 from Artifactory."; exit 1
          fi
          LOCAL_SHA256=$(cut -d' ' -f1 "${ARTIFACT_DIR}/${LOCAL_NAME}.sha256")
          echo "Remote sha256: $REMOTE_SHA256"
          echo "Local  sha256: $LOCAL_SHA256"
          [ "$REMOTE_SHA256" = "$LOCAL_SHA256" ] || { echo "::error::Checksum mismatch."; exit 1; }
          echo "Checksum match ✅"

      - name: Upload artifact (local copy + sha256)
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.stage.outputs.out_name }}
          path: ${{ env.ARTIFACT_DIR }}/*
