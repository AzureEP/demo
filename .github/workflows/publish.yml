# .github/workflows/publish.yml
# Simple: Build, test, and publish JAR to JFrog Artifactory (no <distributionManagement>)
# Version is rewritten to include commit id so Artifactory filenames contain both commit + timestamp.
# Local SHA256/SHA512 files are uploaded as a workflow artifact.

name: Build and Publish to JFrog Artifactory

on:
  push:
    branches: ["main"]
  workflow_dispatch:

permissions:
  contents: read

jobs:
  build-and-publish:
    runs-on: ubuntu-latest

    env:
      # Set these in your repo:
      # Secrets:  JFROG_USER, JFROG_TOKEN
      # Variables: JF_URL (e.g., https://yourorg.jfrog.io),
      #            JF_MVN_SNAPSHOTS_REPO (e.g., maven-snapshots-local),
      #            JF_MVN_RELEASES_REPO  (e.g., maven-releases-local)
      JFROG_USER:  ${{ secrets.JFROG_USER }}
      JFROG_TOKEN: ${{ secrets.JFROG_TOKEN }}
      JF_URL:      ${{ vars.JF_URL }}
      SNAP_REPO:   ${{ vars.JF_MVN_SNAPSHOTS_REPO }}
      REL_REPO:    ${{ vars.JF_MVN_RELEASES_REPO }}

      ARTIFACT_DIR: dist
      MVN_FLAGS: "-B -ntp -C -e"  # batch, no transfer progress, strict checksums, stacktraces

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Writes ~/.m2/settings.xml with <server id="artifactory"> using ENV VAR NAMES below
      - name: Set up JDK 17 + Maven server creds
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "17"
          cache: maven
          server-id: artifactory
          server-username: JFROG_USER      # NAME of env var (not the secret value)
          server-password: JFROG_TOKEN     # NAME of env var (not the secret value)

      - name: Java & Maven versions
        shell: bash
        run: |
          set -eux
          java -version
          mvn -version

      - name: Build timestamp (from last commit)
        id: ts
        shell: bash
        run: |
          set -euo pipefail
          COMMIT_TS=$(git log -1 --format=%ct)
          echo "iso=$(date -u -d @${COMMIT_TS} +%Y-%m-%dT%H:%M:%SZ)" >> "$GITHUB_OUTPUT"
          echo "compact=$(date -u -d @${COMMIT_TS} +%Y%m%dT%H%M%SZ)" >> "$GITHUB_OUTPUT"

      - name: Set version to include commit id (so filenames include it)
        id: ver
        shell: bash
        run: |
          set -euo pipefail
          # Current version from POM
          APP_VER=$(mvn -q -DforceStdout help:evaluate -Dexpression=project.version)
          BASE="${APP_VER%-SNAPSHOT}"                 # strip -SNAPSHOT if present
          SHORT_SHA="${GITHUB_SHA::7}"
          NEW_VER="${BASE}-g${SHORT_SHA}-SNAPSHOT"    # e.g., 3.5.0-gabc1234-SNAPSHOT
          echo "Setting new version: ${NEW_VER}"
          mvn -q -DgenerateBackupPoms=false versions:set -DnewVersion="${NEW_VER}"
          echo "new_version=${NEW_VER}" >> "$GITHUB_OUTPUT"

      - name: Pick target repo (snapshot vs release) and deploy URL
        id: repo
        shell: bash
        run: |
          set -euo pipefail
          if [[ -z "${JF_URL:-}" || -z "${SNAP_REPO:-}" || -z "${REL_REPO:-}" ]]; then
            echo "::error::Missing JF_URL / JF_MVN_* repo variables in Settings â†’ Variables"; exit 1
          fi
          # After the version bump, we always deploy snapshots (NEW_VER ends with -SNAPSHOT)
          REPO="$SNAP_REPO"
          DEPLOY_URL="${JF_URL%/}/artifactory/${REPO}"
          echo "deploy_url=${DEPLOY_URL}" >> "$GITHUB_OUTPUT"
          echo "repo=${REPO}"             >> "$GITHUB_OUTPUT"

      - name: Build & test (reproducible)
        shell: bash
        run: |
          set -euo pipefail
          mvn $MVN_FLAGS -Dproject.build.outputTimestamp="${{ steps.ts.outputs.iso }}" clean verify

      - name: Deploy to Artifactory (Maven repo)
        shell: bash
        env:
          DEPLOY_URL: ${{ steps.repo.outputs.deploy_url }}
        run: |
          set -euo pipefail
          # modern altDeploymentRepository syntax: id::layout::url
          mvn $MVN_FLAGS -DaltDeploymentRepository=artifactory::default::"${DEPLOY_URL}" deploy

      - name: Create local copy + checksums (commit + timestamp for traceability)
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "${ARTIFACT_DIR}"
          SRC_JAR=$(ls target/*.jar | head -n1)   # still ends with -SNAPSHOT locally
          OUT_JAR="spring-petclinic-${{ steps.ver.outputs.new_version }}-${{ steps.ts.outputs.compact }}.jar"
          # Replace the local -SNAPSHOT name with a deterministic one we control:
          cp "${SRC_JAR}" "${ARTIFACT_DIR}/${OUT_JAR}"
          (cd "${ARTIFACT_DIR}" && sha256sum "${OUT_JAR}" > "${OUT_JAR}.sha256")
          (cd "${ARTIFACT_DIR}" && sha512sum "${OUT_JAR}" > "${OUT_JAR}.sha512")
          echo "Generated local traceable files in ${ARTIFACT_DIR}:"
          ls -lah "${ARTIFACT_DIR}"

      - name: Upload workflow artifacts (local copy + checksums)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: jar-${{ github.sha }}
          path: ${{ env.ARTIFACT_DIR }}/*
